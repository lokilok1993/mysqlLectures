/*************************************************************************************************************************************************************************************/

  /*
  * Служебные операторы
  *
  * CREATE TABLE [table] (column type [mod] , [column type [mod]])      - Создание таблицы
  * DESCRIBE (DESC) [table]                                             - Описание таблицы
  * CONSTRAINT                                                          - Ограничение
  * REFERENCES table (column)                                           - Ссылается
  */

  /*
  * Модификаторы столбцов
  *
  * NOT NULL          - не может быть без значения
  * UNSIGNED          - беззнаковое число ( Только положительные числа )
  * AUTO_INCREMENT    - Инкремент ( используется в идентификаторах для обеспечения уникальности )
  */

  /*
  *	Типы данных
  *
  *	CHAR(length)		                    -	Строки константной длинны	( макс 255 символов )
  *	VARCHAR(length)	                    -	Строки переменной длинны	( макс 255 символов )
  *	TINYTEXT			                      -	Маленький текст				    ( макс 255 символов )
  *	TEXT				                        -	Текст						          ( макс 65 535 символов )
  *	MEDIUMTEXT			                    -	Средний текст				      ( макс 16 777 215 символов )
  *	LONGTEXT			                      -	Длинный текст				      ( макс 4 294 967 295 символов )
  * ENUM(A, B)                          - Перечисление и проверочное ограничение в описание типа
  *
  *	TINYINT                             - Мелкое число              ( от -128 до 127 )
  *	SMALLINT                            - Маленькое число           ( от -32 768 до 32 768 )
  *	MEDIUMINT                           - Среднее число             ( от -8 388 608 до 8 388 608 )
  *	INT                                 - Число                     ( от -2 147 483 648 до 2 147 483 648 )
  *	BIGINT                              - Большое число             ( от -9 223 372 036 854 775 808 до 9 223 372 036 854 775 808 )
  *
  * FLOAT(точность масштаб)             - Число с плавающей точкой  ( от -3,402823466E+38 до -1,175494351E-38 и от 1,175494351E-38 до 3,402823466E+38 )
  * DOUBLE(точность масштаб)            - Дробное (более точное)    ( от 1,7976931348623157E+308 до -2,2250738585072014E-308 и от 2,2250738585072014E-308 до 1,7976931348623157E+308 )
  *
  * DATE                                - Дата                      ( Date YYYY-MM-DD )
  * DATETIME                            - Дата и время              ( от 1000-01-01 до 9999-12-31 )
  * TIMESTAMP                           - Временной отпечаток       ( Datetime YYYY-MM-DD HH:MI:SS от 1000-01-01 00:00:00 до 9999-12-31 23:59:59 )
  * YEAR                                - Год                       ( Timestamp YYYY-MM-DD HH:MI:SS от 1970-01-01 00:00:00 до 2037-12-31 23:59:59 )
  * TIME                                - Время                     ( Year YYYY от 1901 до 2155 )
  *
  */

  /*
  * Ограничения
  *
  * CONSTRAINT pk_person PRIMARY KEY (person_id)                                    - Ограничение первичного ключа ( primary key constraint )
  * CONSTRAINT fk_person_id FOREIGN KEY (person_id) REFERENCES person (person_id)   - Ограничения внешнего ключа ( foreign key constraint )
  */

/*************************************************************************************************************************************************************************************/


/*********************************************************************************************/
/*********************************************************************************************/
/*********************************************************************************************/
/*********************************************************************************************/
/*********************************************************************************************/
/*********************************************************************************************/
/*********************************************************************************************/
/*********************                                                     *******************/
/*********************                                                     *******************/
/*********************        2. СОЗДАНИЕ И ЗАПОЛНЕНИЕ БАЗЫ ДАННЫХ         *******************/
/*********************                                                     *******************/
/*********************                                                     *******************/
/*********************************************************************************************/
/*********************************************************************************************/
/*********************************************************************************************/
/*********************************************************************************************/
/*********************************************************************************************/
/*********************************************************************************************/
/*********************************************************************************************/



/* Создание нового пользователя */

  grant all privileges on *.* to 'username'@'localhost' identified by 'password';


/* Выбро текущего времени */

  SELECT now();



/* Создание таблицы person (человек) */

  CREATE TABLE person
    (
      person_id    SMALLINT UNSIGNED,
      fname        VARCHAR(20),
      lname        VARCHAR(20),
      gender       ENUM('M', 'F'),
      birdh_date   DATE,
      address      VARCHAR(30),
      city         VARCHAR(20),
      state        VARCHAR(20),
      country      VARCHAR(20),
      postal_code  VARCHAR(20),
      CONSTRAINT pk_person PRIMARY KEY (person_id)
    );



/* Создание таблицы favorite_food (любимое блюдо) */

  CREATE TABLE favorite_food
    (
      person_id SMALLINT UNSIGNED,
      food VARCHAR(20),
      CONSTRAINT pk_favorite_food PRIMARY KEY (person_id, food),
      CONSTRAINT fk_person_id FOREIGN KEY (person_id) REFERENCES person (person_id)
    );



/* Добовление автоинкремента полю person_id */

  ALTER TABLE person MODIFY person_id SMALLINT UNSIGNED AUTO_INCREMENT;



/* Для изменения поля, которое является внешним ключём для другой таблицы нужно выключить проврку внешних ключей */

  SET FOREIGN_KEY_CHECKS = 0;
  /* DO WHAT YOU NEED HERE */
  SET FOREIGN_KEY_CHECKS = 1;



/* Добавление строки для Вильяма Тёрнера */

  INSERT INTO person (person_id, fname, lname, gender, birdh_date)
  VALUES (null, 'Whilliam', 'Turner', 'M', '1972-05-27');



/* Выбор значений из таблицы person где person_id = 1*/

  SELECT person_id, fname, lname, birdh_date
  FROM person
  WHERE person_id = 1;



/* Добавление любимых блюд Вильяма Тёрнера */

  INSERT INTO favorite_food (person_id, food)
  VALUES (1, 'pizza');

  INSERT INTO favorite_food (person_id, food)
  VALUES (1, 'cookies');

  INSERT INTO favorite_food (person_id, food)
  VALUES (1, 'nachos');



/* Выбор любимых блюд Вильяма Тёрнера */

  SELECT food
  FROM favorite_food
  WHERE person_id = 1
  ORDER BY food;




/*  Добавление Сьюзен Смит */

  INSERT INTO person (person_id, fname, lname, gender, birdh_date, address, city, state, country, postal_code)
  VALUES (null, 'Susan', 'Smith', 'F', '1975-11-02', '23 Maple St.', 'Arlington', 'VA', 'USA', '20220');




/* Обновление данных для Вильяма Тёрнера */

  UPDATE person
  SET
    address = '1225 Tremont St.',
    city = 'Boston',
    state = 'MA',
    country = 'USA',
    postal_code = '02138'
    WHERE person_id = 1;




/* Удаление Сьюзен */

  DELETE FROM person
  WHERE person_id = 2;



/* Удаление тестовых таблиц person и favorite_food */

  DROP TABLE favorite_food;
  DROP TABLE person;



/*********************************************************************************************/
/*********************************************************************************************/
/*********************************************************************************************/
/*********************************************************************************************/
/*********************************************************************************************/
/*********************************************************************************************/
/*********************************************************************************************/
/*********************                                                     *******************/
/*********************                                                     *******************/
/*********************                3. АЗБУКА ЗАПРОСОВ                   *******************/
/*********************                                                     *******************/
/*********************                                                     *******************/
/*********************************************************************************************/
/*********************************************************************************************/
/*********************************************************************************************/
/*********************************************************************************************/
/*********************************************************************************************/
/*********************************************************************************************/
/*********************************************************************************************/


/*
  Банковская система, которая приводится в примерах книги
|-------------------------------------------------------------------------------------------------
| Таблица           | Описание
|-------------------------------------------------------------------------------------------------
| Account           | Конкретный счет, открытый для конкретного клиента
| Business          | Клиент - юридическое лицо (подтип таблицы Customer)
| Customer          | Физическое или юридическое лицо, известные банку
| Department        | Группа сотрудников банка, реализующая определенную банковскую функцию
| Employee          | Человек, работающий в банке
| Individual        | Клиент - физическое лицо (подтип таблицы Customer)
| Officer           | Человек, которому разрешено вести дела от лица клиента юридического лица
| Product           | Услуга банка, предлагаемая клиентам
| Product_type      | Группа функционально схожих услуг
| Transaction       | Изменение баланса счета
|-------------------------------------------------------------------------------------------------
*/

/*
* Блоки запроса
*
* SELECT      - Определяет столбцы, которые должны быть включены в результирующий набор запроса
* FROM        - Указывает таблицы, из которых должны быть извлечены данные, и то, как эти таблицы должны быть соединены
* WHERE       - Ограничивает число строк в окончательном результирующем наборе
* GROUP BY    - Используется для группировки строк по одинаковым значениям столбцов
* HAVING      - Ограничивает число строк в окончательном результирующем наборе с помощью группировки данных
* ORDER BY    - Сортирует строки окончательного результирующего набора по одному или более столбцам
*/



-- БЛОК SELECT



/* Выражение выборки с демонстрацией использования литерала, выражения и вызова встроенной функции */

  SELECT emp_id, 'ACTIVE', emp_id * 3.14159, UPPER(lname);
  FROM employee;



/* Если требуется только выполнить встроенную функцию или вычислить простое выражение, можно вообще обойтись без блока from */

  SELECT VERSION(), USER(), DATABASE();



/* Псевдонимы столбцов ( указываются через пробел после имён столбцов ) */

  SELECT emp_id,
  'ACTIVE'          status,
  emp_id * 3.14159  empid_x_pi,
  UPPER(lname)      last_name_upper
  FROM employee;



/* Выборка данных без дубликатов */

  SELECT DISTINCT cust_id
  FROM account;



-- БЛОК FROM



/* Выборка из таблицы формируемых подзапросом */

  SELECT e.emp_id, e.fname, e.lname
  FROM (SELECT emp_id, fname, lname, start_date, title
        FROM employee
        ) e;



/* Выборка из представления (view) */

  CREATE VIEW employee_vw AS
  SELECT emp_id, fname, lname,
  YEAR(start_date) start_year
  FROM employee;

  SELECT emp_id, start_year
  FROM employee_vw;



/* Выборка из несколькиз таблиц */

  SELECT employee.emp_id, employee.fname, employee.lname, department.name dept_name
  FROM employee INNER JOIN department ON employee.dept_id = department.dept_id;



/* Определение псевдонимов таблиц */

  SELECT e.emp_id, e.fname, e.lname, d.name dept_name
  FROM employee e INNER JOIN department d
  ON e.dept_id = d.dept_id



-- БЛОК WHERE



/* Извлечение только старших операционистов */

  SELECT emp_id, fname, lname, start_date, title
  FROM employee
  WHERE title = 'Head Teller';



/* Извлечение старших операционистов принятых на работу до 2002 года */

  SELECT emp_id, fname, lname, start_date, title
  FROM employee
  WHERE title = 'Head Teller'
  AND  start_date > '2002-01-01';



/* Извлечение старших операционистов и других сотрудников принятых на работу до 2002 года */

  SELECT emp_id, fname, lname, start_date, title
  FROM employee
  WHERE title = 'Head Teller'
  OR start_date > '2002-01-01';



/* Извлечение старших операционистов принятых позже 2002 года или операционистов принятых позже 2003 года */

  SELECT emp_id, fname, lname, start_date, title
  FROM employee
  WHERE (title = 'Head Teller' AND start_date > '2002-01-01')
  OR (title = 'Teller' AND start_date > '2003-01-01');



-- БЛОК ORDER BY



/* Сортировка по идентификатору сотрудника */

  SELECT open_emp_id, product_cd
  FROM account
  ORDER BY open_emp_id;



/* Сортировка по идентификатору сотрудника и типу счёта */

  SELECT open_emp_id, product_cd
  FROM account
  ORDER BY open_emp_id, product_cd;



/* Извлечение списка всех счетов, отсортированного по доступному остатку начиная с самого большого */

  SELECT account_id, product_cd, open_date, avail_balance
  FROM account
  ORDER BY avail_balance DESC;



/* Сортировка с выражением. Сотировка данных клиентов по последним трём разрядам федерального ID */

  SELECT cust_id, cust_type_cd, city, state, fed_id
  FROM customer
  ORDER BY RIGHT(fed_id, 3);



/* Сортировка по номеру столбца в результатирующем наборе */

  SELECT emp_id, title, start_date, fname, lname
  FROM employee
  ORDER BY 2, 5;



-- Упражнения



/* Извлечь id, имя и фамилию всех банковских сотрудников, сортировка по фамилии а затем по имени */

  SELECT emp_id, fname, lname
  FROM employee
  ORDER BY lname, fname;



/* Извлеките ID счета, ID клиента и доступный остаток всех счетов, имеющих статус 'ACTIVE' (активный) и доступный остаток более 2500 долларов. */

  SELECT account_id, cust_id, avail_balance
  FROM account
  WHERE status = 'ACTIVE'
  AND avail_balance > 2500;



/* Извлечь ID сотрудников, отрывших счета (используйте столбец account.open_emp_id). Результирующий набор должен включать по одной строке для каждого сотрудника. */

  SELECT DISTINCT open_emp_id
  FROM account;



/* заполнить дырки */

  SELECT p.product_cd, a.cust_id, a.avail_balance
  FROM product p INNER JOIN account a
  ON p.product_cd = a.product_cd
  WHERE p.product_type_cd = 'ACCOUNT';



/*********************************************************************************************/
/*********************************************************************************************/
/*********************************************************************************************/
/*********************************************************************************************/
/*********************************************************************************************/
/*********************************************************************************************/
/*********************************************************************************************/
/*********************                                                     *******************/
/*********************                                                     *******************/
/*********************                  4. ФИЛЬТРАЦИЯ                      *******************/
/*********************                                                     *******************/
/*********************                                                     *******************/
/*********************************************************************************************/
/*********************************************************************************************/
/*********************************************************************************************/
/*********************************************************************************************/
/*********************************************************************************************/
/*********************************************************************************************/
/*********************************************************************************************/

/*
* Условие фильтрации это одно, или более выражений соединённых операторами
*
* ВЫРАЖЕНИЯ
*
* - Число
* - Столбец таблицы или представления
* - Строковый литерал
* - Встроенная функция, например CONCAT('Learning', ' ', 'sql');
* - Подзапрос
* - Список выражений, например ('Teller', 'Head Teller', 'OperationsManager')
*
* ОПЕРАТОРЫ
*
* - Операторы сравнения, такие как =, !=, <, >, <>, LIKE, IN и BETWEEN
* - Арифметические операторы, такие как +, , * и /
*/

/*
* ВЫРАЖЕНИЯ ПОИСКА
*
* При поиске частичных соответствий строк интерес могут представлять
*
* Строки, начинающиеся/заканчивающиеся определенным символом
* Строки, начинающиеся/заканчивающиеся подстрокой
* Строки, содержащие определенный символ в любом месте строки
* Строки, содержащие подстроку в любом месте строки
* Строки определенного формата, независимо от входящих в них от дельных символов
*
* Символы маски
*
*   _     - Точно один символ
*   %     - Любое число символов (в том числе ни одного)
*
* Примеры выражений поиска
*
*   F%                   - Строки, начинающиеся с «F»
*   %t                   - Строки, заканчивающиеся на «t»
*   %bas%                - Строки, содержащие подстроку «bas»
*   _ _t_                - Строки, состоящие из четырех символов с «t» в третьей позиции
*   _ _ _-_ _-_ _ _ _    - Строки из 11 символов, где четвертый и седьмой символы – дефисы
*/

/*
* NULL - это опеределённое значение, которое применяется в следующих случаях:
*
* Значение неприменимо      - Например, столбец с ID сотрудника для транзакции, которая выполняется с банкоматом.
* Значение еще не известно  - Например, если в момент создания строки клиента федеральный ID неизвестен.
* Значение не определено    - Например, если создается счет для продукта, который еще не был добавлен в БД.
*
*
*
* При работе с null необходимо помнить:
*
* Выражение может быть нулевым (null), но оно никогда не может быть равным нулю.
* Два null никогда не равны друг другу.
* Проверить выражение на значение null можно с помощью оператора is null
*/



/* Скобки и логика. Выбрать операционистов или сотрудников принятых до 2003 года, работающих до сих пор */

  SELECT * FROM employee
  WHERE end_date IS NULL
  AND (title = 'Teller' OR start_date < '2003-01-01');



/* Скобки и логика. Выбрать НЕ операционистов или сотрудников принятых НЕ до 2003 года, работающих до сих пор */

  SELECT * FROM employee
  WHERE end_date IS NULL
  AND NOT (title = 'Teller' OR start_date < '2003-01-01');



/* Условия равенства */

  SELECT pt.name product_type, p.name product
  FROM product p INNER JOIN product_type pt
  ON p.product_type_cd = pt.product_type_cd
  WHERE pt.name = 'Customer Accounts';



/* Удалить счета закрытые в 1999 году */

  DELETE FROM account
  WHERE status = 'CLOSED' AND YEAR(close_date) = 1999;



/* Условия вхождения в диапазон */

  SELECT emp_id, fname, lname start_date
  FROM employee
  WHERE start_date < '2003-01-01'



/* Условия вхождения в диапазон с нижней границей */

  SELECT emp_id, fname, lname, start_date
  FROM employee
  WHERE start_date < '2003-01-01'
  AND start_date >= '2001-01-01';



/* Условия вхождения в диапазон оператор BETWEEN (между) */

  SELECT emp_id, fname, lname, start_date
  FROM employee
  WHERE start_date BETWEEN '2001-01-01' AND '2003-01-01';



/* Условия вхождения в числовой диапазон */

  SELECT account_id, product_cd, cust_id, avail_balance
  FROM account
  WHERE avail_balance BETWEEN 3000 AND 5000;



/* Условия вхождения в строковый диапазон (необходимо знать порядок символов в наборе символов (collation)) */

  SELECT cust_id, fed_id
  FROM customer
  WHERE cust_type_cd = 'I'
  AND fed_id BETWEEN '500-00-0000' AND '999-99-9999';



/* Условия челенства */

  SELECT account_id, product_cd, cust_id, avail_balance
  FROM account
  WHERE product_cd IN ('CHK','SAV','CD','MM');



/* Условия челенства с использованием подзапроса */

  SELECT account_id, product_cd, cust_id, avail_balance
  FROM account
  WHERE product_cd IN (SELECT product_cd FROM product
    WHERE product_type_cd = 'ACCOUNT');



/* Условие отсутствия */

  SELECT account_id, product_cd, cust_id, avail_balance
  FROM account
  WHERE product_cd NOT IN ('CHK','SAV','CD','MM');



/* Условие соответствия ( первая буква фамилии достаётся путём вызова встроенной функции ) */

  SELECT emp_id, fname, lname
  FROM employee
  WHERE LEFT(lname, 1) = 'T';



/* Символы маски */

  SELECT lname
  FROM employee
  WHERE lname LIKE '_a%e%';



/* Выражение поиска по строке маске формата социальной страховки */

  SELECT cust_id, fed_id
  FROM customer
  WHERE fed_id LIKE '___-__-____';



/* Несколько выражений поиска */

  SELECT emp_id, fname, lname
  FROM employee
  WHERE lname LIKE 'G%' OR lname LIKE 'F%';



/* Выражения поиска с использованием регулярных выражений */

  SELECT emp_id, fname, lname
  FROM employee
  WHERE lname REGEXP '^[FG]';



-- Значение NULL



/* Проверка значения на NULL */

  SELECT emp_id, fname, lname, superior_emp_id
  FROM employee
  WHERE superior_emp_id IS NULL;



/* Проверка присутствия значения */

  SELECT emp_id, fname, lname, superior_emp_id
  FROM employee
  WHERE superior_emp_id IS NOT NULL;



/* При работе нужно всегда учитывать что значение может не быть */
/* Выбрать всех сотрудников не подчиняющихся хелен флеминг (С ошибкой) */

  SELECT emp_id, fname, lname, superior_emp_id
  FROM employee
  WHERE superior_emp_id != 6;

/* В этот набор не войдут люди которые никому не подчиняются */
/* Выбрать всех сотрудников не подчиняющихся хелен флеминг (Верный вариант) */

  SELECT emp_id, fname, lname, superior_emp_id
  FROM employee
  WHERE superior_emp_id != 6 OR superior_emp_id IS NULL;



-- Упражнения



/* Создайте запрос, выбирающий все счета, открытые в 2002 году. */

  SELECT *
  FROM account
  WHERE open_date BETWEEN '2002-01-01' AND '2002-12-31';



/*Создайте запрос, выбирающий всех клиентов физических лиц, второй буквой фамилии которых является буква 'a' и есть 'e' в любой позиции после 'a'.*/

  SELECT cust_id, lname, fname
  FROM individual
  WHERE lname LIKE '_a%e%';




/*********************************************************************************************/
/*********************************************************************************************/
/*********************************************************************************************/
/*********************************************************************************************/
/*********************************************************************************************/
/*********************************************************************************************/
/*********************************************************************************************/
/*********************                                                     *******************/
/*********************                                                     *******************/
/*********************          4. ЗАПРОСЫ К НЕСКОЛЬКИМ ТАБЛИЦАМ           *******************/
/*********************                                                     *******************/
/*********************                                                     *******************/
/*********************************************************************************************/
/*********************************************************************************************/
/*********************************************************************************************/
/*********************************************************************************************/
/*********************************************************************************************/
/*********************************************************************************************/
/*********************************************************************************************/



/* Декартово (прямое) произведение */

  SELECT e.fname, e.lname, d.name
  FROM employee e JOIN department d;



/* Внутренние соединения ( Тип не указан но если он не указан субд использует внутреннее соединение, хотя лучше всегда указывать ) */

  SELECT e.fname, e.lname, d.name
  FROM employee e JOIN department d
  ON e.dept_id = d.dept_id;



/* Если имена ключей совпадают можно использовать подблок using */

   SELECT e.fname, e.lname, d.name
   FROM employee e INNER JOIN department d
   USING(dept_id);


/* Еще один пример запроса с соединением двух таблиц */

  SELECT a.account_id, c.fed_id
  FROM account a INNER JOIN customer c
  ON a.cust_id = c.cust_id
  WHERE c.cust_type_cd = 'B';



/* Добавление имени операциониста открывшего счёт ( Соединение трёх таблиц ) */

  SELECT a.account_id, c.fed_id, e.fname, e.lname
  FROM account a

  INNER JOIN customer c
  ON a.cust_id = c.cust_id

  INNER JOIN employee e
  ON a.open_emp_id = e.emp_id

  WHERE c.cust_type_cd = 'B';



/* Если изменить порядок присоединяемых таблиц результат не изменится */

  SELECT a.account_id, c.fed_id, e.fname, e.lname
  FROM account a

  INNER JOIN employee e
  ON a.open_emp_id = e.emp_id

  INNER JOIN customer c
  ON a.cust_id = c.cust_id

  WHERE c.cust_type_cd = 'B';



/* Выбор всех счетов, открытых опытными операционистами, в настоящее время работающими в отделении Woburn */
/* Вся фильтрация происходит засчёт внутреннего объединения таблиц, формируемых подзапросами*/

  SELECT *
  FROM account a

  INNER JOIN (
    SELECT emp_id, assigned_branch_id
    FROM employee
    WHERE start_date <= '2003-01-01'
    AND(title = 'Teller' OR title = 'Head Teller')
  ) e
  ON a.open_emp_id = e.emp_id

  INNER JOIN (
    SELECT branch_id
    FROM branch
    WHERE name = 'Woburn Branch'
  ) b
  ON e.assigned_branch_id = b.branch_id;



/* Повторное использование таблицы. */
/* Извлечь сотрудника открвшего каждый текущий счет, в каком отделении это произошло и к какому отделению приписан в настоящее время сотрудник */

  SELECT a.account_id, e.emp_id, b_a.name open_branch, b_e.name emp_branch
  FROM account a

  INNER JOIN branch b_a
  ON a.open_branch_id = b_a.branch_id

  INNER JOIN employee e
  ON a.open_emp_id = e.emp_id

  INNER JOIN branch b_e
  ON e.assigned_branch_id = b_e.branch_id

  WHERE a.product_cd = 'CHK';










































/**************************************************************************************/
/**************************  Завершил на странице 98  *********************************/
/**************************************************************************************/


































