/*************************************************************************************************************************************************************************************/

  /*
  * Служебные операторы
  *
  * CREATE TABLE [table] (column type [mod] , [column type [mod]])      - Создание таблицы
  * DESCRIBE (DESC) [table]                                             - Описание таблицы
  * CONSTRAINT                                                          - Ограничение
  * REFERENCES table (column)                                           - Ссылается
  */

  /*
  * Модификаторы столбцов
  *
  * NOT NULL          - не может быть без значения
  * UNSIGNED          - беззнаковое число ( Только положительные числа )
  * AUTO_INCREMENT    - Инкремент ( используется в идентификаторах для обеспечения уникальности )
  */

  /*
  *	Типы данных
  *
  *	CHAR(length)		                    -	Строки константной длинны	( макс 255 символов )
  *	VARCHAR(length)	                    -	Строки переменной длинны	( макс 255 символов )
  *	TINYTEXT			                      -	Маленький текст				    ( макс 255 символов )
  *	TEXT				                        -	Текст						          ( макс 65 535 символов )
  *	MEDIUMTEXT			                    -	Средний текст				      ( макс 16 777 215 символов )
  *	LONGTEXT			                      -	Длинный текст				      ( макс 4 294 967 295 символов )
  * ENUM(A, B)                          - Перечисление и проверочное ограничение в описание типа
  *
  *	TINYINT                             - Мелкое число              ( от -128 до 127 )
  *	SMALLINT                            - Маленькое число           ( от -32 768 до 32 768 )
  *	MEDIUMINT                           - Среднее число             ( от -8 388 608 до 8 388 608 )
  *	INT                                 - Число                     ( от -2 147 483 648 до 2 147 483 648 )
  *	BIGINT                              - Большое число             ( от -9 223 372 036 854 775 808 до 9 223 372 036 854 775 808 )
  *
  * FLOAT(точность масштаб)             - Число с плавающей точкой  ( от -3,402823466E+38 до -1,175494351E-38 и от 1,175494351E-38 до 3,402823466E+38 )
  * DOUBLE(точность масштаб)            - Дробное (более точное)    ( от 1,7976931348623157E+308 до -2,2250738585072014E-308 и от 2,2250738585072014E-308 до 1,7976931348623157E+308 )
  *
  * DATE                                - Дата                      ( Date YYYY-MM-DD )
  * DATETIME                            - Дата и время              ( от 1000-01-01 до 9999-12-31 )
  * TIMESTAMP                           - Временной отпечаток       ( Datetime YYYY-MM-DD HH:MI:SS от 1000-01-01 00:00:00 до 9999-12-31 23:59:59 )
  * YEAR                                - Год                       ( Timestamp YYYY-MM-DD HH:MI:SS от 1970-01-01 00:00:00 до 2037-12-31 23:59:59 )
  * TIME                                - Время                     ( Year YYYY от 1901 до 2155 )
  *
  */

  /*
  * Ограничения
  *
  * CONSTRAINT pk_person PRIMARY KEY (person_id)                                    - Ограничение первичного ключа ( primary key constraint )
  * CONSTRAINT fk_person_id FOREIGN KEY (person_id) REFERENCES person (person_id)   - Ограничения внешнего ключа ( foreign key constraint )
  */

/*************************************************************************************************************************************************************************************/


/*********************************************************************************************/
/*********************************************************************************************/
/*********************************************************************************************/
/*********************************************************************************************/
/*********************************************************************************************/
/*********************************************************************************************/
/*********************************************************************************************/
/*********************                                                     *******************/
/*********************                                                     *******************/
/*********************        2. СОЗДАНИЕ И ЗАПОЛНЕНИЕ БАЗЫ ДАННЫХ         *******************/
/*********************                                                     *******************/
/*********************                                                     *******************/
/*********************************************************************************************/
/*********************************************************************************************/
/*********************************************************************************************/
/*********************************************************************************************/
/*********************************************************************************************/
/*********************************************************************************************/
/*********************************************************************************************/



/* Создание нового пользователя */

  grant all privileges on *.* to 'username'@'localhost' identified by 'password';


/* Выбро текущего времени */

  SELECT now();



/* Создание таблицы person (человек) */

  CREATE TABLE person
    (
      person_id    SMALLINT UNSIGNED,
      fname        VARCHAR(20),
      lname        VARCHAR(20),
      gender       ENUM('M', 'F'),
      birdh_date   DATE,
      address      VARCHAR(30),
      city         VARCHAR(20),
      state        VARCHAR(20),
      country      VARCHAR(20),
      postal_code  VARCHAR(20),
      CONSTRAINT pk_person PRIMARY KEY (person_id)
    );



/* Создание таблицы favorite_food (любимое блюдо) */

  CREATE TABLE favorite_food
    (
      person_id SMALLINT UNSIGNED,
      food VARCHAR(20),
      CONSTRAINT pk_favorite_food PRIMARY KEY (person_id, food),
      CONSTRAINT fk_person_id FOREIGN KEY (person_id) REFERENCES person (person_id)
    );



/* Добовление автоинкремента полю person_id */

  ALTER TABLE person MODIFY person_id SMALLINT UNSIGNED AUTO_INCREMENT;



/* Для изменения поля, которое является внешним ключём для другой таблицы нужно выключить проврку внешних ключей */

  SET FOREIGN_KEY_CHECKS = 0;
  /* DO WHAT YOU NEED HERE */
  SET FOREIGN_KEY_CHECKS = 1;



/* Добавление строки для Вильяма Тёрнера */

  INSERT INTO person (person_id, fname, lname, gender, birdh_date)
  VALUES (null, 'Whilliam', 'Turner', 'M', '1972-05-27');



/* Выбор значений из таблицы person где person_id = 1*/

  SELECT person_id, fname, lname, birdh_date
  FROM person
  WHERE person_id = 1;



/* Добавление любимых блюд Вильяма Тёрнера */

  INSERT INTO favorite_food (person_id, food)
  VALUES (1, 'pizza');

  INSERT INTO favorite_food (person_id, food)
  VALUES (1, 'cookies');

  INSERT INTO favorite_food (person_id, food)
  VALUES (1, 'nachos');



/* Выбор любимых блюд Вильяма Тёрнера */

  SELECT food
  FROM favorite_food
  WHERE person_id = 1
  ORDER BY food;




/*  Добавление Сьюзен Смит */

  INSERT INTO person (person_id, fname, lname, gender, birdh_date, address, city, state, country, postal_code)
  VALUES (null, 'Susan', 'Smith', 'F', '1975-11-02', '23 Maple St.', 'Arlington', 'VA', 'USA', '20220');




/* Обновление данных для Вильяма Тёрнера */

  UPDATE person
  SET
    address = '1225 Tremont St.',
    city = 'Boston',
    state = 'MA',
    country = 'USA',
    postal_code = '02138'
    WHERE person_id = 1;




/* Удаление Сьюзен */

  DELETE FROM person
  WHERE person_id = 2;



/* Удаление тестовых таблиц person и favorite_food */

  DROP TABLE favorite_food;
  DROP TABLE person;



/*********************************************************************************************/
/*********************************************************************************************/
/*********************************************************************************************/
/*********************************************************************************************/
/*********************************************************************************************/
/*********************************************************************************************/
/*********************************************************************************************/
/*********************                                                     *******************/
/*********************                                                     *******************/
/*********************                3. АЗБУКА ЗАПРОСОВ                   *******************/
/*********************                                                     *******************/
/*********************                                                     *******************/
/*********************************************************************************************/
/*********************************************************************************************/
/*********************************************************************************************/
/*********************************************************************************************/
/*********************************************************************************************/
/*********************************************************************************************/
/*********************************************************************************************/


/*
  Банковская система, которая приводится в примерах книги
|-------------------------------------------------------------------------------------------------
| Таблица           | Описание
|-------------------------------------------------------------------------------------------------
| Account           | Конкретный счет, открытый для конкретного клиента
| Business          | Клиент - юридическое лицо (подтип таблицы Customer)
| Customer          | Физическое или юридическое лицо, известные банку
| Department        | Группа сотрудников банка, реализующая определенную банковскую функцию
| Employee          | Человек, работающий в банке
| Individual        | Клиент - физическое лицо (подтип таблицы Customer)
| Officer           | Человек, которому разрешено вести дела от лица клиента юридического лица
| Product           | Услуга банка, предлагаемая клиентам
| Product_type      | Группа функционально схожих услуг
| Transaction       | Изменение баланса счета
|-------------------------------------------------------------------------------------------------
*/

/*
* Блоки запроса
*
* SELECT      - Определяет столбцы, которые должны быть включены в результирующий набор запроса
* FROM        - Указывает таблицы, из которых должны быть извлечены данные, и то, как эти таблицы должны быть соединены
* WHERE       - Ограничивает число строк в окончательном результирующем наборе
* GROUP BY    - Используется для группировки строк по одинаковым значениям столбцов
* HAVING      - Ограничивает число строк в окончательном результирующем наборе с помощью группировки данных
* ORDER BY    - Сортирует строки окончательного результирующего набора по одному или более столбцам
*/



-- БЛОК SELECT



/* Выражение выборки с демонстрацией использования литерала, выражения и вызова встроенной функции */

  SELECT emp_id, 'ACTIVE', emp_id * 3.14159, UPPER(lname);
  FROM employee;



/* Если требуется только выполнить встроенную функцию или вычислить простое выражение, можно вообще обойтись без блока from */

  SELECT VERSION(), USER(), DATABASE();



/* Псевдонимы столбцов ( указываются через пробел после имён столбцов ) */

  SELECT emp_id,
  'ACTIVE'          status,
  emp_id * 3.14159  empid_x_pi,
  UPPER(lname)      last_name_upper
  FROM employee;



/* Выборка данных без дубликатов */

  SELECT DISTINCT cust_id
  FROM account;



-- БЛОК FROM



/* Выборка из таблицы формируемых подзапросом */

  SELECT e.emp_id, e.fname, e.lname
  FROM (SELECT emp_id, fname, lname, start_date, title
        FROM employee
        ) e;



/* Выборка из представления (view) */

  CREATE VIEW employee_vw AS
  SELECT emp_id, fname, lname,
  YEAR(start_date) start_year
  FROM employee;

  SELECT emp_id, start_year
  FROM employee_vw;



/* Выборка из несколькиз таблиц */

  SELECT employee.emp_id, employee.fname, employee.lname, department.name dept_name
  FROM employee INNER JOIN department ON employee.dept_id = department.dept_id;



/* Определение псевдонимов таблиц */

  SELECT e.emp_id, e.fname, e.lname, d.name dept_name
  FROM employee e INNER JOIN department d
  ON e.dept_id = d.dept_id



-- БЛОК WHERE



/* Извлечение только старших операционистов */

  SELECT emp_id, fname, lname, start_date, title
  FROM employee
  WHERE title = 'Head Teller';



/* Извлечение старших операционистов принятых на работу до 2002 года */

  SELECT emp_id, fname, lname, start_date, title
  FROM employee
  WHERE title = 'Head Teller'
  AND  start_date > '2002-01-01';



/* Извлечение старших операционистов и других сотрудников принятых на работу до 2002 года */

  SELECT emp_id, fname, lname, start_date, title
  FROM employee
  WHERE title = 'Head Teller'
  OR start_date > '2002-01-01';



/* Извлечение старших операционистов принятых позже 2002 года или операционистов принятых позже 2003 года */

  SELECT emp_id, fname, lname, start_date, title
  FROM employee
  WHERE (title = 'Head Teller' AND start_date > '2002-01-01')
  OR (title = 'Teller' AND start_date > '2003-01-01');



-- БЛОК ORDER BY



/* Сортировка по идентификатору сотрудника */

  SELECT open_emp_id, product_cd
  FROM account
  ORDER BY open_emp_id;



/* Сортировка по идентификатору сотрудника и типу счёта */

  SELECT open_emp_id, product_cd
  FROM account
  ORDER BY open_emp_id, product_cd;



/* Извлечение списка всех счетов, отсортированного по доступному остатку начиная с самого большого */

  SELECT account_id, product_cd, open_date, avail_balance
  FROM account
  ORDER BY avail_balance DESC;



/* Сортировка с выражением. Сотировка данных клиентов по последним трём разрядам федерального ID */

  SELECT cust_id, cust_type_cd, city, state, fed_id
  FROM customer
  ORDER BY RIGHT(fed_id, 3);



/* Сортировка по номеру столбца в результатирующем наборе */

  SELECT emp_id, title, start_date, fname, lname
  FROM employee
  ORDER BY 2, 5;



-- Упражнения



/* Извлечь id, имя и фамилию всех банковских сотрудников, сортировка по фамилии а затем по имени */

  SELECT emp_id, fname, lname
  FROM employee
  ORDER BY lname, fname;



/* Извлеките ID счета, ID клиента и доступный остаток всех счетов, имеющих статус 'ACTIVE' (активный) и доступный остаток более 2500 долларов. */

  SELECT account_id, cust_id, avail_balance
  FROM account
  WHERE status = 'ACTIVE'
  AND avail_balance > 2500;



/* Извлечь ID сотрудников, отрывших счета (используйте столбец account.open_emp_id). Результирующий набор должен включать по одной строке для каждого сотрудника. */

  SELECT DISTINCT open_emp_id
  FROM account;



/* заполнить дырки */

  SELECT p.product_cd, a.cust_id, a.avail_balance
  FROM product p INNER JOIN account a
  ON p.product_cd = a.product_cd
  WHERE p.product_type_cd = 'ACCOUNT';



/*********************************************************************************************/
/*********************************************************************************************/
/*********************************************************************************************/
/*********************************************************************************************/
/*********************************************************************************************/
/*********************************************************************************************/
/*********************************************************************************************/
/*********************                                                     *******************/
/*********************                                                     *******************/
/*********************                  4. ФИЛЬТРАЦИЯ                      *******************/
/*********************                                                     *******************/
/*********************                                                     *******************/
/*********************************************************************************************/
/*********************************************************************************************/
/*********************************************************************************************/
/*********************************************************************************************/
/*********************************************************************************************/
/*********************************************************************************************/
/*********************************************************************************************/

/*
* Условие фильтрации это одно, или более выражений соединённых операторами
*
* ВЫРАЖЕНИЯ
*
* - Число
* - Столбец таблицы или представления
* - Строковый литерал
* - Встроенная функция, например CONCAT('Learning', ' ', 'sql');
* - Подзапрос
* - Список выражений, например ('Teller', 'Head Teller', 'OperationsManager')
*
* ОПЕРАТОРЫ
*
* - Операторы сравнения, такие как =, !=, <, >, <>, LIKE, IN и BETWEEN
* - Арифметические операторы, такие как +, , * и /
*/

/*
* ВЫРАЖЕНИЯ ПОИСКА
*
* При поиске частичных соответствий строк интерес могут представлять
*
* Строки, начинающиеся/заканчивающиеся определенным символом
* Строки, начинающиеся/заканчивающиеся подстрокой
* Строки, содержащие определенный символ в любом месте строки
* Строки, содержащие подстроку в любом месте строки
* Строки определенного формата, независимо от входящих в них от дельных символов
*
* Символы маски
*
*   _     - Точно один символ
*   %     - Любое число символов (в том числе ни одного)
*
* Примеры выражений поиска
*
*   F%                   - Строки, начинающиеся с «F»
*   %t                   - Строки, заканчивающиеся на «t»
*   %bas%                - Строки, содержащие подстроку «bas»
*   _ _t_                - Строки, состоящие из четырех символов с «t» в третьей позиции
*   _ _ _-_ _-_ _ _ _    - Строки из 11 символов, где четвертый и седьмой символы – дефисы
*/

/*
* NULL - это опеределённое значение, которое применяется в следующих случаях:
*
* Значение неприменимо      - Например, столбец с ID сотрудника для транзакции, которая выполняется с банкоматом.
* Значение еще не известно  - Например, если в момент создания строки клиента федеральный ID неизвестен.
* Значение не определено    - Например, если создается счет для продукта, который еще не был добавлен в БД.
*
*
*
* При работе с null необходимо помнить:
*
* Выражение может быть нулевым (null), но оно никогда не может быть равным нулю.
* Два null никогда не равны друг другу.
* Проверить выражение на значение null можно с помощью оператора is null
*/



/* Скобки и логика. Выбрать операционистов или сотрудников принятых до 2003 года, работающих до сих пор */

  SELECT * FROM employee
  WHERE end_date IS NULL
  AND (title = 'Teller' OR start_date < '2003-01-01');



/* Скобки и логика. Выбрать НЕ операционистов или сотрудников принятых НЕ до 2003 года, работающих до сих пор */

  SELECT * FROM employee
  WHERE end_date IS NULL
  AND NOT (title = 'Teller' OR start_date < '2003-01-01');



/* Условия равенства */

  SELECT pt.name product_type, p.name product
  FROM product p INNER JOIN product_type pt
  ON p.product_type_cd = pt.product_type_cd
  WHERE pt.name = 'Customer Accounts';



/* Удалить счета закрытые в 1999 году */

  DELETE FROM account
  WHERE status = 'CLOSED' AND YEAR(close_date) = 1999;



/* Условия вхождения в диапазон */

  SELECT emp_id, fname, lname start_date
  FROM employee
  WHERE start_date < '2003-01-01'



/* Условия вхождения в диапазон с нижней границей */

  SELECT emp_id, fname, lname, start_date
  FROM employee
  WHERE start_date < '2003-01-01'
  AND start_date >= '2001-01-01';



/* Условия вхождения в диапазон оператор BETWEEN (между) */

  SELECT emp_id, fname, lname, start_date
  FROM employee
  WHERE start_date BETWEEN '2001-01-01' AND '2003-01-01';



/* Условия вхождения в числовой диапазон */

  SELECT account_id, product_cd, cust_id, avail_balance
  FROM account
  WHERE avail_balance BETWEEN 3000 AND 5000;



/* Условия вхождения в строковый диапазон (необходимо знать порядок символов в наборе символов (collation)) */

  SELECT cust_id, fed_id
  FROM customer
  WHERE cust_type_cd = 'I'
  AND fed_id BETWEEN '500-00-0000' AND '999-99-9999';



/* Условия челенства */

  SELECT account_id, product_cd, cust_id, avail_balance
  FROM account
  WHERE product_cd IN ('CHK','SAV','CD','MM');



/* Условия челенства с использованием подзапроса */

  SELECT account_id, product_cd, cust_id, avail_balance
  FROM account
  WHERE product_cd IN (SELECT product_cd FROM product
    WHERE product_type_cd = 'ACCOUNT');



/* Условие отсутствия */

  SELECT account_id, product_cd, cust_id, avail_balance
  FROM account
  WHERE product_cd NOT IN ('CHK','SAV','CD','MM');



/* Условие соответствия ( первая буква фамилии достаётся путём вызова встроенной функции ) */

  SELECT emp_id, fname, lname
  FROM employee
  WHERE LEFT(lname, 1) = 'T';



/* Символы маски */

  SELECT lname
  FROM employee
  WHERE lname LIKE '_a%e%';



/* Выражение поиска по строке маске формата социальной страховки */

  SELECT cust_id, fed_id
  FROM customer
  WHERE fed_id LIKE '___-__-____';



/* Несколько выражений поиска */

  SELECT emp_id, fname, lname
  FROM employee
  WHERE lname LIKE 'G%' OR lname LIKE 'F%';



/* Выражения поиска с использованием регулярных выражений */

  SELECT emp_id, fname, lname
  FROM employee
  WHERE lname REGEXP '^[FG]';



-- Значение NULL



/* Проверка значения на NULL */

  SELECT emp_id, fname, lname, superior_emp_id
  FROM employee
  WHERE superior_emp_id IS NULL;



/* Проверка присутствия значения */

  SELECT emp_id, fname, lname, superior_emp_id
  FROM employee
  WHERE superior_emp_id IS NOT NULL;



/* При работе нужно всегда учитывать что значение может не быть */
/* Выбрать всех сотрудников не подчиняющихся хелен флеминг (С ошибкой) */

  SELECT emp_id, fname, lname, superior_emp_id
  FROM employee
  WHERE superior_emp_id != 6;

/* В этот набор не войдут люди которые никому не подчиняются */
/* Выбрать всех сотрудников не подчиняющихся хелен флеминг (Верный вариант) */

  SELECT emp_id, fname, lname, superior_emp_id
  FROM employee
  WHERE superior_emp_id != 6 OR superior_emp_id IS NULL;



-- Упражнения



/* Создайте запрос, выбирающий все счета, открытые в 2002 году. */

  SELECT *
  FROM account
  WHERE open_date BETWEEN '2002-01-01' AND '2002-12-31';



/*Создайте запрос, выбирающий всех клиентов физических лиц, второй буквой фамилии которых является буква 'a' и есть 'e' в любой позиции после 'a'.*/

  SELECT cust_id, lname, fname
  FROM individual
  WHERE lname LIKE '_a%e%';




/*********************************************************************************************/
/*********************************************************************************************/
/*********************************************************************************************/
/*********************************************************************************************/
/*********************************************************************************************/
/*********************************************************************************************/
/*********************************************************************************************/
/*********************                                                     *******************/
/*********************                                                     *******************/
/*********************          5. ЗАПРОСЫ К НЕСКОЛЬКИМ ТАБЛИЦАМ           *******************/
/*********************                                                     *******************/
/*********************                                                     *******************/
/*********************************************************************************************/
/*********************************************************************************************/
/*********************************************************************************************/
/*********************************************************************************************/
/*********************************************************************************************/
/*********************************************************************************************/
/*********************************************************************************************/



/* Декартово (прямое) произведение */

  SELECT e.fname, e.lname, d.name
  FROM employee e JOIN department d;



/* Внутренние соединения ( Тип не указан но если он не указан субд использует внутреннее соединение, хотя лучше всегда указывать ) */

  SELECT e.fname, e.lname, d.name
  FROM employee e JOIN department d
  ON e.dept_id = d.dept_id;



/* Если имена ключей совпадают можно использовать подблок using */

   SELECT e.fname, e.lname, d.name
   FROM employee e INNER JOIN department d
   USING(dept_id);


/* Еще один пример запроса с соединением двух таблиц */

  SELECT a.account_id, c.fed_id
  FROM account a INNER JOIN customer c
  ON a.cust_id = c.cust_id
  WHERE c.cust_type_cd = 'B';



/* Добавление имени операциониста открывшего счёт ( Соединение трёх таблиц ) */

  SELECT a.account_id, c.fed_id, e.fname, e.lname
  FROM account a

  INNER JOIN customer c
  ON a.cust_id = c.cust_id

  INNER JOIN employee e
  ON a.open_emp_id = e.emp_id

  WHERE c.cust_type_cd = 'B';



/* Если изменить порядок присоединяемых таблиц результат не изменится */

  SELECT a.account_id, c.fed_id, e.fname, e.lname
  FROM account a

  INNER JOIN employee e
  ON a.open_emp_id = e.emp_id

  INNER JOIN customer c
  ON a.cust_id = c.cust_id

  WHERE c.cust_type_cd = 'B';



/* Выбор всех счетов, открытых опытными операционистами, в настоящее время работающими в отделении Woburn */
/* Вся фильтрация происходит засчёт внутреннего объединения таблиц, формируемых подзапросами*/

  SELECT *
  FROM account a

  INNER JOIN (
    SELECT emp_id, assigned_branch_id
    FROM employee
    WHERE start_date <= '2003-01-01'
    AND(title = 'Teller' OR title = 'Head Teller')
  ) e
  ON a.open_emp_id = e.emp_id

  INNER JOIN (
    SELECT branch_id
    FROM branch
    WHERE name = 'Woburn Branch'
  ) b
  ON e.assigned_branch_id = b.branch_id;



/* Повторное использование таблицы. */
/* Извлечь сотрудника открвшего каждый текущий счет, в каком отделении это произошло и к какому отделению приписан в настоящее время сотрудник */

  SELECT a.account_id, e.emp_id, b_a.name open_branch, b_e.name emp_branch
  FROM account a

  INNER JOIN branch b_a
  ON a.open_branch_id = b_a.branch_id

  INNER JOIN employee e
  ON a.open_emp_id = e.emp_id

  INNER JOIN branch b_e
  ON e.assigned_branch_id = b_e.branch_id

  WHERE a.product_cd = 'CHK';



/* Рекурсивное соединение таблицы с самой собой по ( self referencing foreign key ) [ Псевдонимы таблиц обязательны ] */
/* Вывести список сотрудников с указанием их начальников */

  SELECT e.fname, e.lname, e_mgr.fname mgr_fname, e_mgr.lname mgr_lname
  FROM employee e INNER JOIN employee e_mgr
  ON e.superior_emp_id = e_mgr.emp_id;



/* Рекурсивное неэквисоединение, то есть соединение таблицы с сомой собой не по условию равенства  */
/* Составить поры всех сотрудников для шахматного турнира */

  SELECT e1.fname, e1.fname, 'VS' vs, e2.fname, e2.lname
  FROM employee e1 INNER JOIN employee e2
  ON e1.emp_id != e2.emp_id
  WHERE e1.title = 'Teller' AND e2.title = 'Teller';



/* хитрость для избежания обратных пар сотрудников с результатирующем наборе */

  SELECT e1.fname, e1.fname, 'VS' vs, e2.fname, e2.lname
  FROM employee e1 INNER JOIN employee e2
  ON e1.emp_id > e2.emp_id
  WHERE e1.title = 'Teller' AND e2.title = 'Teller';



-- Упражнения по внутренним соединениям



/*  */

  SELECT e.emp_id, e.fname, e.lname, b.name
  FROM employee e INNER JOIN branch b
  ON e.assigned_branch_id = b.branch_id;



/* Напишите запрос, по которому для каждого клиента физического
лица (customer.cust_type_cd = 'I') возвращаются ID счета, федеральный ID
(customer.fed_id) и тип созданного счета (product.name). */

  SELECT a.account_id, c.fed_id, p.name
  FROM account a

  INNER JOIN customer c
  ON a.cust_id = c.cust_id

  INNER JOIN product p
  ON a.product_cd = p.product_cd;



/* Создайте запрос для выбора всех сотрудников, начальник которых приписан к другому отделу. Извлеките ID, имя и фамилию сотрудника. */

  SELECT e1.emp_id, e1.fname, e1.lname
  FROM employee e1 INNER JOIN employee e2
  ON e1.superior_emp_id = e2.emp_id
  WHERE e1.dept_id != e2.dept_id;



/*********************************************************************************************/
/*********************************************************************************************/
/*********************************************************************************************/
/*********************************************************************************************/
/*********************************************************************************************/
/*********************************************************************************************/
/*********************************************************************************************/
/*********************                                                     *******************/
/*********************                                                     *******************/
/*********************               6. РАБОТА С МНОЖЕСТВАМИ               *******************/
/*********************                                                     *******************/
/*********************                                                     *******************/
/*********************************************************************************************/
/*********************************************************************************************/
/*********************************************************************************************/
/*********************************************************************************************/
/*********************************************************************************************/
/*********************************************************************************************/
/*********************************************************************************************/

/*
* Три выида операций по множествами
*
* 1) Объединение  ( UNION )         [ Все данные из двух множеств ]                                                       - ПОДДЕРЖИВАЕТСЯ mysql
* 2) Пересечение  ( INTERSECT )     [ Все пересекающиеся данные из двух множеств  ]                                       - НЕ ПОДДЕРЖИВАЕТСЯ mysql
* 3) Разность     ( EXCEPT )        [ Все данные из первого множества, кроме данных пересекающихся со вторым множеством ] - НЕ ПОДДЕРЖИВАЕТСЯ mysql
*/


/* Операции с множествами осуществляются путем помещения оператора
   работы с множествами (set operator) между двух выражений select,
   как показано ниже: */

  SELECT 1 num, 'abc' str
  UNION
  SELECT 9 num, 'xyz' str;



/* Формирование полного множества данных клиентов из двух таблиц */

  SELECT cust_id, lname name
  FROM individual
  UNION ALL
  SELECT cust_id, name
  FROM business;



/* При использовании оператора полного множества повторные строки не удаляются */

  SELECT cust_id, lname name
  FROM individual
  UNION ALL
  SELECT cust_id, name
  FROM business
  UNION ALL
  SELECT cust_id, name
  FROM business;



/* Ещё один пример дублирования строк при извлечении полного множества */

  SELECT emp_id
  FROM employee
  WHERE assigned_branch_id = 2
    AND (title = 'Teller' OR title = 'Head Teller')
  UNION ALL
  SELECT DISTINCT open_emp_id
  FROM account
  WHERE open_branch_id = 2;



/* Если необходимо исключить дублирующие значения необходимо использовать оператор union */

  SELECT emp_id
  FROM employee
  WHERE assigned_branch_id = 2
    AND (title = 'Teller' OR title = 'Head Teller')
  UNION
  SELECT DISTINCT open_emp_id
  FROM account
  WHERE open_branch_id = 2;



/* Как бы выглядел оператор пересечения, если бы он был в mysql ( В данном примере множества не пересекаются так что empty set ) */

  SELECT emp_id, fname, lname
  FROM employee
  INTERSECT
  SELECT cust_id, fname, lname
  FROM individual;



/* Как бы выглядел оператор пересечения в mysql с пересечением в множествах ( emp_id:10 )*/

  SELECT emp_id
  FROM employee
  WHERE assigned_branch_id = 2
  AND (title = 'Teller' OR title = 'Head Teller')
  INTERSECT
  SELECT DISTINCT open_emp_id
  FROM account
  WHERE open_branch_id = 2;



/* Как бы выглядел оператор разности, если бы он был в mysql */

  SELECT emp_id
  FROM employee
  WHERE assigned_branch_id = 2
  AND (title = 'Teller' OR title = 'Head Teller')
  EXCEPT
  SELECT DISTINCT open_emp_id
  FROM account
  WHERE open_branch_id = 2;



/* Если требуется отсортровать результаты состовного запроса после последнего входящего в него запроса можно добавить блок order by
   В блоке order by указываются имена столбцов из первого запроса составного запроса */

  SELECT emp_id, assigned_branch_id
  FROM employee
  WHERE title = 'Teller'
  UNION
  SELECT open_emp_id, open_branch_id
  FROM account
  WHERE product_cd = 'SAV'
  ORDER BY emp_id;



/* Приоритет операций. Пример состовного запроса из трёх запросов */

  SELECT cust_id
  FROM account
  WHERE product_cd IN ('SAV', 'MM')
  UNION ALL
  SELECT a.cust_id
  FROM account a INNER JOIN branch b
  ON a.open_branch_id = b.branch_id
  WHERE b.name = 'Woburn Branch'
  UNION
  SELECT cust_id
  FROM account
  WHERE avail_balance BETWEEN 500 AND 2500;



-- Упражнения с множествами



/* Имеются множество A = {L M N O P} и множество B = {P Q R S T}. Какие множества будут получены в результате следующих операций: */

A union B - { L M N O P Q R S T }
A union all B - { L M N O P P Q R S T }
A intersect B - { P }
A except B - { L M N O }



/* Напишите составной запрос для выбора имен и фамилий всех клиентов физических лиц, а также имен и фамилий всех сотрудников. */

  SELECT fname, lname
  FROM individual
  UNION
  SELECT fname, lname
  FROM employee



/* Отсортируйте результаты упражнения 6.2 по столбцу lname. */

  SELECT fname, lname
  FROM individual
  UNION
  SELECT fname, lname
  FROM employee
  ORDER BY lname;



/*********************************************************************************************/
/*********************************************************************************************/
/*********************************************************************************************/
/*********************************************************************************************/
/*********************************************************************************************/
/*********************************************************************************************/
/*********************************************************************************************/
/*********************                                                     *******************/
/*********************                                                     *******************/
/*********************   7. СОЗДАНИЕ, ПРЕОБРАЗОВАНИЕ И РАБОТА С ДАННЫМИ    *******************/
/*********************                                                     *******************/
/*********************                                                     *******************/
/*********************************************************************************************/
/*********************************************************************************************/
/*********************************************************************************************/
/*********************************************************************************************/
/*********************************************************************************************/
/*********************************************************************************************/
/*********************************************************************************************/



-- Строковые данные



/* Талица для иллюстрирования работы со строковыми данными */

  CREATE TABLE string_tbl(
    char_fld    CHAR(30),
    vchar_fld   VARCHAR(30),
    text_fld    TEXT
  );



/* Самый простой способ заполнить символьный столбец – заключить строку в кавычки */

  INSERT INTO string_tbl (char_fld, vchar_fld, text_fld)
  VALUES (
    'This is char data',
    'This is varchar data',
    'This is text data'
  );



/* следующее выражение update пытается обновить строкой из 46 символов столбец vchar_fld, для которого задан максимальный размер в 30 символов */
/* В книге написано что строка обрежется и будет варнинг но по делу была ошибка и строка не вставилась ( Новый mysql новые правила )  */

  UPDATE string_tbl
  SET vchar_fld = 'This is a piece of exttemely long varchr data';



/* Экранирование апострофов ещё одним апострофом */

  UPDATE string_tbl
  SET text_fld = 'this does''t work last time, but work now ';



/* При извлечении строки для дальнейшего использования в других программах можно пользоваться встроенной функцией QUOTE,
 Которая возвращает строку с заэкранированными символами */

  SELECT QUOTE(text_fld)
  FROM string_tbl;



/* Использование функций конкатенации и вывода символа по номеру в кодировке */

  SELECT CONCAT('danke sch', CHAR(148), 'N');



/* Возвращение и искодному ( Почемуто в книге это исходное ) состоянию таблицы string_tbl */

  DELETE FROM string_tbl;
  INSERT INTO string_tbl ( char_fld, vchar_fld, text_fld )
  VALUES(
    'This string is 28 characters',
    'This string is 28 characters',
    'This string is 28 characters'
  );



-- Строковые функции, возвращающие числа



/* Функция, возвращающая длинну строки LENGTH() */

  SELECT
    LENGTH(char_fld) char_length,
    LENGTH(vchar_fld) char_length,
    LENGTH(text_fld) char_length
  FROM string_tbl;



/* Функция, возвращающая позицию вхождения подстроки POSITION() [ Нумерация позиции с еденицы (1) ] */

  SELECT POSITION('characters' IN vchar_fld)
  FROM string_tbl;



/* Функция, возвращающая позицию вхождения подстроки начиная поиск с определённой позиции LOCATE() */

  SELECT LOCATE('is', vchar_fld, 5)
  FROM string_tbl;



-- Строковые функции, возвращающие строки



/* Функция конкотенации строк CONCAT() */

  UPDATE string_tbl
  SET text_fld = CONCAT( text_fld, 'this string was added by CONCAT function' );



/* Построение строки из отдельных частей данных с помощью CONCAT() */

  SELECT CONCAT(fname, ' ', lname, ' has been a ', title, ' since ', start_date) emp_narrative
  FROM employee
  WHERE title = 'Teller' OR title = 'Head Teller';



/* Функция добавляющая строку в определённую позицию другой строки INSERT( STR, STRPOS, CUTSTR, INSERTSTR ) */

  SELECT INSERT('goodbye world', 9, 0, 'cruel ') string;



/* Если третий аргумент больше нуля, то замещающая строка замещает указанное количество символов, например: */

  SELECT INSERT('goodbye world', 1, 7, 'hello') string;



/* Функция извлекающая указанное число символов, начиная с заданной позиции. SUBSTING
   В следующем примере из строки извлекается пять символов, начиная с девятой позиции */

  SELECT SUBSTRING('goodbye cruel world', 9, 5);



-- Числовые данные ( Арифметика, точность дробных чисел и обработка чисел со знаком [ чушь ] )



-- Временные данные



/* Создание временных данных */

-- Копирование даты из имеющегося столбца типа date, datetime или time
-- Выполнение встроенной функции, возвращающей значение типа date, datetime или time
-- Создание строкового представления временных данных, которое потом преобразовывается сервером



/* Строковое представление данных */

-- YYYY    Год, включая столетие       от 1000 до 9999
-- MM      Месяц                       от 01 (январь) до 12 (декабрь)
-- DD      День                        от 01 до 31
-- HH      Час                         от 00 до 23
-- HHH     Часы (прошедшие)            от –838 до 838
-- MI      Минута                      от 00 до 59
-- SS      Секунда                     от 00 до 59



/* Чтобы создать строку, которая может быть интерпретирована сервером как тип date, datetime или time, необходимо свести различные компоненты вместе в порядке */

-- Date          YYYY-MM-DD
-- Datetime      YYYY-MM-DD HH:MI:SS
-- Timestamp     YYYY-MM-DD HH:MI:SS
-- Time          HHH:MI:SS



/* Функция принудительно приводящая значение строки к временному значению CAST */

  SELECT CAST('2005-03-27 15:30:00' AS DATETIME);



/* Формирование значений datetime и time */

  SELECT CAST('2005-03-27' AS DATE) date_field,
    CAST('108:17:57' AS TIME) time_field;



/* Все нижеприведённые строки приведутся к дате в mysql */

-- '2005-03-27 15:30:00'
-- '2005/03/27 15:30:00'
-- '2005,03,27,15,30,00'
-- '20050327153000'



/* Функция str_to_date() Приводит строку к временому значению по переданному вторым параметром формату строки */

  UPDATE individual
  SET birth_date = STR_TO_DATE('Match 27, 2005', '%M %d, &Y')
  WHERE cust_id = 9999;



/* Компоненты форматирвоания для функции str_to_date */

-- %M     Название месяца (от January до December)
-- %m     Номер месяца (от 01 до 12)
-- %d     Число (от 01 до 31)
-- %j     День года (от 001 до 366)
-- %W     Дни недели (от Sunday до Saturday)
-- %Y     Год, четырехзначное число
-- %y     Год, двузначное число
-- %H     Час (от 00 до 23)
-- %h     Час (от 01 до 12)
-- %i     Минуты (от 00 до 59)
-- %s     Секунды (от 00 до 59)
-- %f     Микросекунды (от 000000 до 999999)
-- %p     A.M. или P.M.



/* date_add() позволяет добавить любой интервал (т. е. дни, месяцы, года) к заданной дате, чтобы получить другую дату */

  SELECT DATE_ADD(CURRENT_DATE( ), INTERVAL 5 DAYS);



/* Типы интервалов для функции date_add */

-- Second            Количество секунд
-- Minute            Количество минут
-- Hour              Количество часов
-- Day               Количество дней
-- Month             Количество месяцев
-- Year              Количество лет
-- Minute_second     Количества минут и секунд, разделенные двоеточием
-- Hour_second       Количества часов, минут и секунд, разделенные двоеточием
-- Year_month        Количества лет и месяцев, разделенные дефмсом



/* Добавить к значению в таблице время ( сделка была на 3 часа 27 минут и 11 секунд позже ) */

  UPDATE transaction
  SET txn_date = DATE_ADD( txn_date, INTERVAL '3:27:11' HOUR_SECOND)
  WHERE txn_id = 9999;



/* Сотрудник моложе заявленного возраста на 9 лет и 11 месяцев */

  UPDATE employee
  SET birth_date = DATE_ADD(birth_date, INTERVAL '9-11' YEAR_MONTH)
  WHERE emp_id = 4789



/* Функция, возвращающая последний день месяца last_date() */

  SELECT LAST_DAY('2005-03-25');



/* функция, возвращающая дату, преобразует значение типа datetime из одного временного пояса в другой */

  SELECT CURRENT_TIMESTAMP() current_est,
    CONVERT_TZ(CURRENT_TIMESTAMP(), 'US/Eastern', 'UTS') current_uts;



/* Функция, возвращающая название дня */

  SELECT DAYNAME('2005-03-22');



/* extract() использует те же типы интервалов, что и функция date_add() */

  SELECT EXTRACT(YEAR FROM '2005-03-22 22:19:05');



/* datediff возвращает колличество полных дней между двумя датами */

  SELECT DATEDIFF('2005-09-05', '2005-06-22');



/* Если переставить аргументы, поместив первой более раннюю дату, datediff() вернет отрицательное число */

  SELECT DATEDIFF('2005-06-22', '2005-09-05');



/* Пример приобразования строки в число */

  SELECT CAST('1456328' AS SIGNED INTEGER)



/* Преабразует до первого вхождения чимвола, который не приводится к числу */

  SELECT CAST('999ABC111' AS UNSIGNED INTEGER);



-- Упаржнения



/* Напишите запрос, возвращающий с 17-го по 25-й символы строки 'Please find the substring in this string' */

  SELECT SUBSTRING( 'Please find the substring in this string', 17, 9);



/* Напишите запрос, возвращающий только значение месяца текущей даты. */

  SELECT EXTRACT(MONTH FROM CURRENT_TIMESTAMP());




/***************************************************************************************/
/**************************  Завершил на странице 154  *********************************/
/***************************************************************************************/


































